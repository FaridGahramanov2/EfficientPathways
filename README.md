1 Introduction
In the city of X, you have a delivery company “SpeedyShip”. However, your company faced tough times due to the economic reasons of the country. Finan- cial difficulties compelled them to sell their entire fleet, leaving them with only a single delivery truck. Now, with only a single vehicle remaining, you need to develop a plan to efficiently serve all their delivery points in the city. With just one vehicle left, SpeedyShip has a big challenge: taking packages all over the city without spending too much on fuel (i.e., reducing total traveling time). That’s where the Capacitated Single Vehicle Routing Problem (CSVRP), which is an extension version of Travelling Salesperson Problem (TSP), comes into play.
You need to create a route plan among nodes (i.e., depot and stores) by minimizing the total traveling distance for this single vehicle. The vehicle starts from the depot node and goes back to the depot node at the end. Each store node has a distinct amount of load to be collected. The vehicle must visit all store nodes to collect whole loads to deliver to depot. However, it won’t be able to collect entire loads from all store nodes in a single departure due to the vehicle’s load capacity. Instead, it needs to return multiple times to the depot node to unload before continuing to unvisited store nodes. Note that each store node must be visited exactly once while the depot node can be visited more than one. Besides, split delivery is not allowed, meaning that when the vehicle visits a store node, it must pick up all the loads intended for that node. Lastly, the distance matrix indicating the distance between two nodes is provided. Each node has a unique distance to another node, and the graph is fully connected and directed. This means that the departure and return distances between two nodes may vary.
For this assignment, you need to solve the problem described above with three different tree search algorithms: Depth First Search, Uniform Cost Search and A∗ . For this purpose, you need to implement these methods in Python pro- gramming language, then write a report including the implementation details, heuristic functions and performance evaluation of the algorithms.
2 Implementation
A code base is provided for this assignment. You have to use this code base to implement your DFS, UCS and A∗ algorithms. The code base is written in Python programming language (Python 3.10 is recommended). During imple- mentation, any external Python library and Jupyter are not allowed. Instead, you should carefully examine the code base and read comments. Inside the code base:
• Data.py: Data class holds the necessary parameters of a given problem set. This class can read a problem set from a file, and generate a random problem set. You can access the distance from a node to another node and the vehicle load capacity. Moreover, you can check the feasibility of a given solution (i.e., the validity of the route), and calculate the objective value (i.e., total traveling distance).
• Node.py: Node class consists of required parameters of a task (unique node id, whether the node is depot, or store, and the load amount to be collected).
• Solver.py: Solver abstract class is a concept for any solver for this as- signment problem. Each solver must implement solve method finding a solution. Solution must indicate the visiting route as a sequence of nodes.
• RandomSolver.py: RandomSolver class is a sub-class of Solver class that generate a random solution. This solver is provided to denote an example solver implementation.
• DFS.py: DFS class is a sub-class of Solver class that employs Depth First Search algorithm to solve problem. For Assignment 1, you have to implement your DFS algorithm in solve method. You are free to make changes (i.e., defining variables and methods) in this class. However, you cannot change the name of the class, the constructor of the class and the definition of solve method.
• UCS.py: UCS class is a sub-class of Solver class that employs Uniform Cost Search algorithm to solve problem. For Assignment 1, you have to implement your UCS algorithm in solve method. You are free to make changes (i.e., defining variables and methods) in this class. However, you cannot change the name of the class, the constructor of the class and the definition of solve method.
• AStar.py: AStar class is a sub-class of Solver class that employs A∗ algorithm to solve problem. For Assignment 1, you have to implement your A∗ algorithm in solve method. You are free to make changes (i.e., defining variables and methods) in this class. However, you cannot change the name of the class, the constructor of the class and the definition of solve method.
2
• Main.py: This Main script is provided for your implementation. You are free to make any changes in this Python file. Note that, we will test your algorithm in our “Main” file. To use this Python script, all you need is defining a proper data file path in “FILE PATH “ variable.
Briefly, you will implement Depth First Search, Uniform Cost Search and A∗ algorithms with Python programming language in the corresponding methods and classes. You cannot make any change in Python files except “‘DFS.py”, “UCS.py”, “AStar.py” and “Main.py”. Do not forget to read the comments in all methods.
3 Tree-Search Algorithms
In this course, you learned tree-search algorithms. For this assignment, you will implement three tree-search algorithms which are Depth First Search, Uniform Cost Search and A∗ . The corresponding slides for tree-search algorithms are on LMS. Shortly, Depth First Search (DFS) traverses all nodes in a tree graph fol- lowing a last-in, first-out approach, while Breadth First Search (BFS) explores nodes in a first-in, first-out manner. Furthermore, the Uniform Cost Search (UCS) approach is a variant of BFS algorithm which prioritizes the not expanded nodes in a tree to maximize/minimize the pre-defined objective function. Like in Uniform Cost Search, A∗ prioritizes the nodes to expand. The difference is that the prioritizing of A∗ depends on not only the objective function but also the heuristic function. The heuristic function guides the tree-search operation to improve the performance of the A∗ algorithm in terms of computational time and value of the objective function. If the heuristic function is admissible, it is guaranteed that A∗ will find the optimal solution. Uniform Cost Search can be defined as in Equation 1, and A∗ can be defined as in Equation 2, where g(n) is the objective function and h(n) is the heuristic function.
fucs(n) = g(n) (1) fA∗(n) = g(n) + h(n) (2)
For Depth First Search, Uniform Cost Search and A∗ , you should fill solve method in “DFS.py”, “UCS.py” and “AStar.py” files respectively. You can define new variables and methods, but you cannot change the name and the parameters of “solve” method. Additionally, you must define your heuristic value calculation for A∗ , and you must explain it in the report in detail, such as why you decided on this approach, etc.
